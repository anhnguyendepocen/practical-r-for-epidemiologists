# More graphical functions {#exercise8}

Graphical functions in `R` are just like any other function in `R` in the sense that `R` provides you with a set of functions which can be altered or added to. In this exercise we will experiment with some of the graphical functions provided by R to demonstrate the flexibility of graphical functions in `R`. We will then use the graphical functions that we experiment with to create some useful graphical functions of our own.

The first function that we will develop will be a function that is capable of plotting two data series on a single graph. We will take this exercise slowly in order to introduce some further graphical functions.
Before we go any further we should start `R` and retrieve a dataset:

```{r, eval = TRUE}
mal <- read.table("malaria.dat", header = TRUE)
attach(mal)
```

The file `malaria.dat` contains data on rainfall (in mm) and the number of cases of malaria reported from health centres in an administrative district of Ethiopia between July 1997 and July 1999. The columns in this dataset are as follows:

+----------+----------------------------------------+
| **Time** | Month and year (as text)               |
+----------+----------------------------------------+
| **Cases**| Number of cases of malaria reported    |
+----------+----------------------------------------+
| **Rain** | Rainfall in mm                         |
+----------+----------------------------------------+

Examine the dataset:

```{r, eval = TRUE}
mal
```

First we will plot the number of cases of malaria seen over time using the `plot()` function: 

```{r, eval = TRUE}
plot(Cases, type = "l")
```

The problem with this plot is that it does not treat the data as a time series. Adding the `Time` variable to the plot does not solve the problem:

```{r, eval = TRUE}
plot(Time, Cases, type = "l")
```

Because `Time` is a factor variable. If you convert `Time` to a character variable using `as.character()` or prevent `R` from converting `Time` to a factor using the `as.is` parameter to the `read.table()` function the `plot()` function will return an error because it expects a numeric x-axis variable. We should, instead, specify a time series (`ts`) class object. Rather than change the original data, we will create a new object using the `ts()` function:

```{r, eval = TRUE}
cases.ts <- ts(Cases, start = c(1997, 7), frequency = 12)
```

Examine the cases.ts object:

```{r, eval = TRUE}
cases.ts
```

We can now plot `cases.ts` as a time series: 

```{r, eval = TRUE}
plot(cases.ts)
```

We might want to explore the association between the `Rain` and `Cases` variables. A simple scatter plot is not particularly informative:

```{r, eval = TRUE}
plot(Rain, Cases)
```

It is better to treat both variables as time series (which they are) and use the built-in `plot()` methods for objects of class `ts`:

```{r, eval = TRUE}
rain.cases.ts <- ts(cbind(Rain, Cases), start = c(1997,7), frequency = 12)
plot(rain.cases.ts)
```

The association between the `Rain` and `Cases` variables is now clearer with the number of malaria cases peaking shortly after peaks in rainfall.

The `plot()` function when used with objects of class `ts` produces useful output but it is not particularly flexible and the output is, sometimes, not particularly pretty. We can however use basic graphical functions to produce multiple plots. First we will set the `mfrow` graphical parameter using the `par()` function:

```{r, eval = TRUE}
par(mfrow = c(2, 1))
```

The `par()` function sets a graphical parameter. The `mfrow` parameter is used to set the number of charts that will appear on a page in rows and columns. We have specified two rows with one chart per row. Test this by plotting two charts:

```{r, eval = TRUE}
plot(Rain, type = "l")
plot(Cases, type = "l")
```

We will want to have tick-marks on the x-axis of each for each record. We can set the number of tick-marks on axes by setting the `lab` graphical parameter using the `par()` function:

```{r, eval = TRUE}
par(lab = c(length(Time), 10, 7))
```

The `par()` function sets a graphical parameter. The `lab` parameter is used to set the number tick-marks on the x and y axes and the label size. We have specified a tick-mark on the x-axis for each record (i.e. using `length(Time)`), ten tick-marks on the y-axis, and a label length of seven. Test this by plotting two charts:

```{r, eval = TRUE}
plot(Rain, type = "l")
plot(Cases, type = "l")
```

The problem with these charts is that the month and year are not displayed on the x-axis. We can get round this by plotting a chart without axes and then specifying the axes and labels directly:

```{r, eval = TRUE}
plot(Rain, type = "l", axes = FALSE, xlab = "Time", ylab = "mm", main = "Rainfall")
axis(side = 1, labels = as.character(Time), at = 1:length(Time))
axis(side = 2)
plot(Cases, type = "l", axes = FALSE, xlab = "Time", ylab = "n", main = "Cases")
axis(side = 1, labels = as.character(Time), at = 1:length(Time))
axis(side = 2)
```

The resulting charts now look much better (you may need to resize the plot to display the x-axis labels correctly) but it would be nice to be able draw the two lines on a single chart.

Before proceeding we will use the `par()` function to specify one plot per window (using the `mfrow` parameter) and set the default number of tick-marks on the axes (using the `lab` parameter):

```{r, eval = TRUE}
par(mfrow = c(1, 1))
par(lab = c(5, 5, 7))
```

And then use the `plot()` and `lines()` function to draw the two lines on the same graph: 

```{r, eval = TRUE}
plot(Cases, type = "l")
lines(Rain, lty = 2)
```

The problem with this is that the ranges of the two variables are different and the `plot()` function automatically sets the y-axis to the range of the specified variable. To fix this problem we need to set the limits of the y-axis to the minimum and maximum value of both of variables using the `ylim` parameter of the `plot()` function:

```{r, eval = TRUE}
plot(Cases, type = "l", ylim = c(min(Cases, Rain), max(Cases, Rain)))
lines(Rain, lty = 2)
```

We can improve the chart by adding a legend:

```{r, eval = FALSE}
legend(18, 1000, legend = c("Cases", "Rainfall (mm)"), lty = c(1,2))
```

```{r, echo = FALSE, eval = TRUE}
plot(Cases, type = "l", ylim = c(min(Cases, Rain), max(Cases, Rain)))
lines(Rain, lty = 2)
legend(18, 1000, legend = c("Cases", "Rainfall (mm)"), lty = c(1,2))
```

We could continue to improve the chart (e.g. by adding labels for the x-axis tick-marks taken from the `Time` variable, specifying more meaningful axis labels, and specifying a title) but the chart would be more useful if each variable made full use of the plotting area. We can do this by plotting one chart on top of another by using the `new` graphical parameter:

```{r, eval = TRUE}
par(lab = c(length(Time), 5, 7))
plot(Cases, type = "l", lty = 1, axes = FALSE)
axis(side = 2)
par(new = TRUE)
plot(Rain, type = "l", lty = 2, axes = FALSE)
axis(side = 4)
axis(side = 1)
```

This chart is much clearer but there are still some improvements that could be made:

* The chart should have a title. We can do this using the `main` parameter of either of the `plot()` functions.

* The y-axis labels are displayed on top of each other beside the left-hand y-axis. We can solve this problem by preventing the second `plot()` function from displaying a y-axis label (i.e. by specifying an empty character string for the `ylab` parameter).

* We will need to make room on the right-hand side of the chart for an axis label (i.e. by setting the `mar` (margin) graphical parameter) and place the label there ourselves (using the `mtext()` function).

* The x-axis should display the month and year which are held as character strings in the `Time` variable. We can do this using the labels parameter of the `axis()` function after setting the appropriate number of tick-marks using the `lab` graphical parameter.

The x-axis should be properly labelled. We can do this using the `xlab` parameters of the `plot()` functions. An empty string must be specified for one of the `plot()` functions in order to prevent the default label from being displayed.

Try this now:

```{r, eval = TRUE}
par(mar = c(5, 5, 4, 5))
par(lab = c(length(Time), 5, 7))
plot(Cases, type = "l", lty = 1, axes = FALSE,
     xlab = "", ylab = "", main = "Malaria cases and rainfall")
axis(side = 2)
mtext(text = "Malaria cases", side = 2, line = 3)
par(new = TRUE)
plot(Rain, type = "l", lty = 2, axes = FALSE,
     xlab = "Month & Year", ylab = "")
axis(side = 4)
mtext(text = "Rainfall (mm)", side = 4, line = 3)
axis(side = 1, labels = as.character(Time), at = 1:length(Time))
```

Now that we know how to create a two-axis chart, we can write a function that we will be able to use whenever we need to plot two variables on the same chart. Create a new function called `plot2var()`:

```{r, eval = FALSE}
plot2var <- function() {}
```

This creates an empty function called `plot2var()`.

Use the `fix()` function to edit the `plot2var()` function:

```{r, eval = FALSE}
fix(plot2var)
```

Edit the function to read:
   
```{r, eval = FALSE}
function(y1,
         y2,
         x.ticks,
         x.lab = deparse(substitute(x.ticks)),
         y1.lab = deparse(substitute(y1)),
         y2.lab = deparse(substitute(y2)),
         main = paste(y1.lab, "&", y2.lab)) {
  old.par.mar <- par("mar")
  old.par.lab <- par("lab")
  par(mar = c(5, 5, 4, 5))
  if(!missing(x.ticks)) {par(lab = c(length(x.ticks), 5, 7))}
  plot(y1, type = "l", lty = 1, axes = FALSE,
       xlab = "", ylab = "", main = main)
  axis(side = 2)
  mtext(text = y1.lab, side = 2, line = 3)
  par(new = TRUE)
  plot(y2, type = "l", lty = 2, axes = FALSE,
       ylab = "", xlab = x.lab)
  axis(side = 4)
  mtext(text = y2.lab, side = 4, line = 3)
  if(!missing(x.ticks)) {
    axis(side = 1, labels = as.character(x.ticks),
         at = 1:length(x.ticks))
  } else {axis(side = 1)}
  par(mar = old.par.mar)
  par(lab = old.par.lab)
}
```
```{r, echo = FALSE, eval = TRUE}
plot2var <- function(y1,
           y2,
           x.ticks,
           x.lab = deparse(substitute(x.ticks)),
           y1.lab = deparse(substitute(y1)),
           y2.lab = deparse(substitute(y2)),
           main = paste(y1.lab, "&", y2.lab)) {
  old.par.mar <- par("mar")
  old.par.lab <- par("lab")
  par(mar = c(5, 5, 4, 5))
  if(!missing(x.ticks)) {par(lab = c(length(x.ticks), 5, 7))}
  plot(y1, type = "l", lty = 1, axes = FALSE,
       xlab = "", ylab = "", main = main)
  axis(side = 2)
  mtext(text = y1.lab, side = 2, line = 3)
  par(new = TRUE)
  plot(y2, type = "l", lty = 2, axes = FALSE,
       ylab = "", xlab = x.lab)
  axis(side = 4)
  mtext(text = y2.lab, side = 4, line = 3)
  if(!missing(x.ticks)) {
    axis(side = 1, labels = as.character(x.ticks),
         at = 1:length(x.ticks))
  } else {axis(side = 1)}
  par(mar = old.par.mar)
  par(lab = old.par.lab)  
}
```

Once you have made the changes shown above, save the file and quit the editor.

Note that with this function we have given some of the parameters default values in the function definition and we have also used the `if()` function to check whether the user specified a value for the `x.ticks` parameter. We also save and restore the graphical parameters `mar` and `lab` so as to prevent changes to these parameters in the `plot2var()` function affecting other graphical functions.

Let's try the `plot2var()` function with the test data: 

```{r, eval = FALSE}
plot2var(Rain, Cases)
plot2var(Rain, Cases, Time)
```

```{r, echo = FALSE, eval = TRUE}
plot2var(Rain, Cases)
plot2var(Rain, Cases, Time)
```

Note how the function has used default values for the axis labels and chart title. We can override these default values if we want to:

```{r, eval = TRUE}
plot2var(Rain, Cases, Time, x.lab = "Month and Year",
         y1.lab = "Rainfall (mm)", y2.lab = "Cases of malaria")
```

You might like to use the `save()` function to save the `plot2var()` function.

As an exercise you might want to edit the `plot2var()` function to automatically add a legend to the two-axis
chart using the `legend()` function with `y1.lab` and `y2.lab`. Before continuing we should detach the `mal` data.frame:

```{r, eval = TRUE}
detach(mal)
```

## Population pyramid

A common chart type that is not available in many statistical applications and in `R` is the *population pyramid*. 

Before we go any further we should retrieve a dataset:

```{r, eval = TRUE}
pop <- read.table("pop.dat", header = TRUE)
attach(pop)
```

The file `pop.dat` contains data on the age (in months) and sex of 438 children aged between six and sixty months collected as part of a nutritional anthropometry survey of the Khosh Valley in Northeast Afghanistan.

The columns in this dataset are as follows:

+----------+----------------------------+
| **AGE**  | Age of the child in months |
+----------+----------------------------+
| **SEX**  | Sex of the child (M/F)     |
+----------+----------------------------+

Examine the first twenty records of the dataset:

```{r, eval = TRUE}
pop[1:20, ]
```

The first step is to make groups from the `AGE` variable since many ages are biased towards full years: 

```{r, eval = FALSE}
table(AGE)
barplot(table(AGE), col = "white")
```

```{r, echo = FALSE, eval = TRUE}
table(AGE)
barplot(table(AGE), col = "white")
```

So we will centre the age-groups around the months representing full years:

```{r, eval = TRUE}
age.group <- cut(AGE, c(0, 17, 29, 41, 53, 99))
```

We can check that the grouping operation has worked as expected by tabulating `AGE` and `age.group`: 

```{r, eval = TRUE}
table(AGE, age.group)
```

We now use the `table()` function to produce the summary data for the population pyramid: 

```{r, eval = TRUE}
table(age.group, SEX)
```

We will construct our population pyramid using the `barplot()` function: 

```{r, eval = TRUE}
barplot(table(age.group, SEX))
```

The default behaviour of the `barplot()` function is to produce stacked bars. We can set the `beside` parameter to display the bars side-by-side:

```{r, eval = TRUE}
barplot(table(age.group, SEX), beside = TRUE)
```

We can also use the `horiz` parameter to present the data as horizontal bars: 

```{r, eval = TRUE}
barplot(table(age.group, SEX), beside = TRUE, horiz = TRUE)
```

In order to centre the bars around zero we need to make one column of the summary data table contain negative numbers:

```{r, eval = TRUE}
tab <- table(age.group, SEX)
tab
tab[ ,1] <- -tab[ ,1]
tab
barplot(tab, beside = TRUE, horiz = TRUE)
```

This is looking better.

We still need to shift the second set of bars down beside the first set of bars using thespace parameter:

```{r, eval = TRUE}
barplot(tab, beside = TRUE, horiz = TRUE, space = c(0, -nrow(tab)))
```

The axis labels are wrong but we can fix that using the `names.arg` parameter:

```{r, eval = TRUE}
bar.names <- c(dimnames(tab)$age.group, dimnames(tab)$age.group)
barplot(tab, beside = TRUE, horiz = TRUE, space = c(0, -nrow(tab)),
        names.arg = bar.names)
```

The chart can still be improved upon by making the fill-colour of each bar white and by expanding the x-axis slightly:

```{r, eval = TRUE}
barplot(tab, beside = TRUE, horiz = TRUE, space = c(0, -nrow(tab)),
        col = "white", xlim = c(min(tab) * 1.2, max(tab) * 1.2),
        names.arg = bar.names)
```


The chart would be better if the x-axis displayed only positive numbers:

```{r, eval = TRUE}
barplot(tab, beside = TRUE, horiz = TRUE, space = c(0, -nrow(tab)),
        col = "white", xlim = c(min(tab) * 1.2, max(tab) * 1.2),
        names.arg = bar.names, axes = FALSE)
axis(side = 1,
     labels = abs(axTicks(side = 1)),
     at = (axTicks(side = 1)))
```

Now we know how to create a population pyramid, we can write a function that we will be able to use whenever we need to plot a population pyramid.

Create a new function called `pyramid.plot()`: 

```{r, eval = FALSE}
pyramid.plot <- function() {}
```

This creates an empty function called `pyramid.plot()`.

Use the `fix()` function to edit the `pyramid.plot()` function:

```{r, eval = FALSE}
fix(pyramid.plot)
```

Edit the function to read:

```{r, eval = FALSE}
function(x,
         g,
         main = paste("Pyramid plot of", deparse(substitute(x)),
                      "by", deparse(substitute(g))),
         xlab = paste(deparse(substitute(g)),
                      "(", levels(g)[1], "/",levels(g)[2],")"),
         ylab = deparse(substitute(x))) {
  tab <- table(x, g)
  tab[ ,1] <- -tab[ ,1]
  barplot(tab,
          horiz = TRUE,
          beside = TRUE,
          space = c(0, -nrow(tab)),
          names.arg = c(dimnames(tab)$x, dimnames(tab)$x),
          xlim = c(min(tab) * 1.2,
          max(tab) * 1.2),
          col = "white",
          main = main,
          xlab = xlab,
          ylab = ylab,
          axes = FALSE)
  axis(side = 1,
       labels = abs(axTicks(side = 1)),
       at = (axTicks(side = 1)))
}
```

```{r, echo = FALSE, eval = TRUE}
pyramid.plot <- function(x,
                          g,
                          main = paste("Pyramid plot of", deparse(substitute(x)),
                                       "by", deparse(substitute(g))),
                          xlab = paste(deparse(substitute(g)),
                                       "(", levels(g)[1], "/",levels(g)[2],")"),
                          ylab = deparse(substitute(x))) {
  tab <- table(x, g)
  tab[ ,1] <- -tab[ ,1]
  barplot(tab,
          horiz = TRUE,
          beside = TRUE,
          space = c(0, -nrow(tab)),
          names.arg = c(dimnames(tab)$x, dimnames(tab)$x),
          xlim = c(min(tab) * 1.2,
          max(tab) * 1.2),
          col = "white",
          main = main,
          xlab = xlab,
          ylab = ylab,
          axes = FALSE)
  axis(side = 1,
       labels = abs(axTicks(side = 1)),
       at = (axTicks(side = 1)))
}
```

Note that with this function we have given some of the parameters default values in the function definition.

Giving default values to parameters is useful because it means that you do not need to specify parameters such as titles and axis labels unless you want to. Many `R` functions use default parameters which are usually set to the most frequently used values.

Once you have made the changes shown above, check your work, save the file, and quit the editor. Let's try the `pyramid.plot()` function with the test data:

```{r, eval = TRUE}
pyramid.plot(age.group, SEX)
```

Note how the function has used default values for the axis labels and chart titles. We can override these default values if we want to:

```{r, eval = TRUE}
pyramid.plot(age.group, SEX, ylab = "Months", xlab = "Sex F / M",
             main = "Children by age and sex")
```

You might like to use the `save()` function to save the `pyramid.plot()` function.

## Pareto chart

Another type of chart that is missing from many statistical applications is the *Pareto* chart which is a bar chart where the bars are sorted by the bar value with the largest bar drawn first. Such a chart is easier to interpret than a pie chart, particularly when there are more than a few categories being plotted.

Before we go any further we should detach the `pop` data.frame and retrieve a new dataset:

```{r, eval = TRUE}
detach(pop)
sssw <- read.table("sssw.dat", header = TRUE)
attach(sssw)
```

The file `sssw.dat` contains data on the marital status, home circumstances, and ethnic group of 152 persons recruited into a study into the levels of stress experienced by student social workers in the United Kingdom. The columns in this dataset are as follows:

+---------------+----------------------------------------+
| **marital**   | Marital status coded as:               |
|               |                                        |
|               |       1 = Married                      |
|               |                                        |
|               |       2 = Single                       |
|               |                                        |
|               |       3 = Divorced                     |
|               |                                        |
|               |       4 = Separated                    |
|               |                                        |
|               |       5 = Cohabiting                   |
|               |                                        |
|               |       6 = Widowed                      |
+---------------+----------------------------------------+
| **living**    | Living with ... coded as:              |
|               |                                        |
|               |       1 = Alone                        |
|               |                                        |
|               |       2 = Parents or siblings          |
|               |                                        |
|               |       3 = Partner                      |
|               |                                        |
|               |       4 = Partner and children         |
|               |                                        |
|               |       5 = Children                     |
|               |                                        |
|               |       6 = Friends or colleagues        |
+---------------+----------------------------------------+
| **ethnic**    | Ethnic group coded as:                 |
|               |                                        |
|               |       1 = African                      |
|               |                                        |
|               |       2 = West-Indian                  |
|               |                                        |
|               |       3 = Indian                       |
|               |                                        |
|               |       4 = Pakistani                    |
|               |                                        |
|               |       5 = Bangladeshi                  |
|               |                                        |
|               |       6 = East African Asian           |
|               |                                        |
|               |       7 = Chinese                      |
|               |                                        |
|               |       8 = Cypriot                      |
|               |                                        |
|               |       9 = Black European               |
|               |                                        |
|               |      10 = White European               |
|               |                                        |
|               |      11 = Other                        |
+---------------+----------------------------------------+

Examine the dataset:

```{r, eval = TRUE}
sssw[1:20, ]
```

Producing a bar chart from this data is simple as long as we remember to pass summary data (i.e. created using the `table()` function) to the `barplot()` function instead of the variable name:

```{r, eval = FALSE}
barplot(table(marital))
barplot(table(living))
barplot(table(ethnic))
```

```{r, echo = FALSE, eval = TRUE}
barplot(table(marital))
barplot(table(living))
barplot(table(ethnic))
```

Creating a Pareto chart only requires us to sort the summary data. We do this using the `rev()` and `sort()` functions:

```{r, eval = TRUE}
barplot(rev(sort(table(marital))))
```

Having to specify `rev(sort(table(variable)))` each time we want to produce a *Pareto* plot is rather tedious but now that we know how to create a *Pareto* chart, we can write a function that we will be able to use whenever we need to plot a Pareto chart. Create a new function called `pareto()`:

```{r, eval = FALSE}
pareto <- function() {}
```

This creates an empty function called `pareto()`. Use the `fix()` function to edit the `pareto()` function: 

```{r, eval = FALSE}
fix(pareto)
```

Edit the function to read:

```{r, eval = FALSE}
function(x,
         xlab = deparse(substitute(x)),
         ylab = "Count",
         main = paste("Pareto Chart of", deparse(substitute(x)))) {
  barplot(rev(sort(table(x))),
          xlab = xlab,
          ylab = ylab,
          main = main,
          col = "white")
}
```

```{r, echo = FALSE, eval = TRUE}
pareto <- function(x,
                   xlab = deparse(substitute(x)),
                   ylab = "Count",
                   main = paste("Pareto Chart of", deparse(substitute(x)))) {
  barplot(rev(sort(table(x))),
          xlab = xlab,
          ylab = ylab,
          main = main,
          col = "white")
}
```

Once you have made the changes shown above, check your work, save the file, and quit the editor. 

Let's try the `pareto()` function with the test data:
   
```{r, eval = TRUE}
pareto(marital)
```

Note how the function has used default values for the axis labels and chart titles. We can override these default values if we want to:

```{r, eval = TRUE}
pareto(marital, ylab = "n", xlab = "Marital Status",
       main = "Marital Status")
```

Note that we can use value labels if the variable we plot is a factor with value labels as levels rather than a simple numeric vector:

```{r, eval = FALSE}
ms <- as.factor(marital)
levels(ms) <- c("Married", "Single", "Divorced", "Separated",
                "Cohabiting", "Widowed")
table(ms)
pareto(ms, ylab = "n", xlab = "Marital Status",
       main = "Marital Status")
```

```{r, echo = FALSE, eval = TRUE}
ms <- as.factor(marital)
levels(ms) <- c("Married", "Single", "Divorced", "Separated",
                "Cohabiting", "Widowed")
table(ms)
pareto(ms, ylab = "n", xlab = "Marital Status",
       main = "Marital Status")
```

You may need to resize the plot to display the x-axis labels correctly.

You might like to use the `save()` function to save the `pareto()` function.


